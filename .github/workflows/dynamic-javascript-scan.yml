
name: Dynamic JavaScript Code Scan

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      scan_tools:
        description: 'Comma-separated list of tools to run'
        required: false
        default: 'eslint,plato'
      project_name:
        description: 'Project name for reporting'
        required: false
        default: 'javascript-project'

env:
  REPORT_DIR: scan-reports

jobs:
  javascript-scan:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Install dependencies
      run: |
        if [ -f "package.json" ]; then
          npm install
        else
          echo "No package.json found, skipping npm install"
        fi
        
    - name: Install scanning tools
      run: |
        npm install -g eslint npm-audit-ci retire plato jsdoc jscpd
        
    - name: Create report directory
      run: mkdir -p $REPORT_DIR
      
    - name: Run JavaScript code scans
      run: |
        echo "Starting JavaScript code scans..."
        echo 'Running ESLint...'\n        echo '{"extends": ["eslint:recommended"], "env": {"browser": true, "node": true}, "parserOptions": {"ecmaVersion": 2018}}' > .eslintrc.json && eslint . --format=json --output-file=$REPORT_DIR/eslint.json 2>/dev/null || echo '[]' > $REPORT_DIR/eslint.json\n        echo 'Running Plato Complexity Analysis...'\n        plato -r -d $REPORT_DIR/plato . 2>/dev/null || (mkdir -p $REPORT_DIR/plato && echo '{"reports": {}}' > $REPORT_DIR/plato/report.json)
        echo "All scans completed. Reports saved to $REPORT_DIR"
        
    - name: Generate severity summary
      run: |
        node << 'SCRIPT_EOF'
        const fs = require('fs');
        const path = require('path');

        const reportDir = process.env.REPORT_DIR || 'scan-reports';
        let severitySummary = {
            "critical": [],
            "high": [],
            "medium": [],
            "low": [],
            "info": []
        };
        
        // Process ESLint results
        if (fs.existsSync(reportDir + '/eslint.json')) {
            try {
                const eslintData = JSON.parse(fs.readFileSync(reportDir + '/eslint.json', 'utf8'));
                if (Array.isArray(eslintData) && eslintData.length > 0) {
                    eslintData.forEach(result => {
                        if (result.severity === 2) {
                            severitySummary.high.push({
                                'tool': 'eslint',
                                'file': result.filePath,
                                'line': result.lineNumber,
                                'issue': result.ruleId,
                                'message': result.message || 'ESLint error'
                            });
                        } else if (result.severity === 1) {
                            severitySummary.medium.push({
                                'tool': 'eslint',
                                'file': result.filePath,
                                'line': result.lineNumber,
                                'issue': result.ruleId,
                                'message': result.message || 'ESLint warning'
                            });
                        }
                    });
                }
            } catch (e) {
                console.log('Error processing eslint.json: ' + e);
            }
        }
        
        // Process Plato results
        if (fs.existsSync(reportDir + '/plato/report.json')) {
            try {
                const platoData = JSON.parse(fs.readFileSync(reportDir + '/plato/report.json', 'utf8'));
                if (platoData && platoData.reports) {
                    Object.keys(platoData.reports).forEach(file => {
                        const report = platoData.reports[file];
                        if (report.complexity && report.complexity.aggregate && report.complexity.aggregate.complexity.cyclomatic > 10) {
                            severitySummary.medium.push({
                                'tool': 'plato',
                                'file': file,
                                'issue': 'High complexity',
                                'message': 'Cyclomatic complexity: ' + report.complexity.aggregate.complexity.cyclomatic
                            });
                        }
                    });
                }
            } catch (e) {
                console.log('Error processing plato/report.json: ' + e);
            }
        }
        
        // Process npm_audit results
        if (fs.existsSync(reportDir + '/npm_audit.json')) {
            try {
                const npmData = JSON.parse(fs.readFileSync(reportDir + '/npm_audit.json', 'utf8'));
                if (npmData.vulnerabilities && npmData.vulnerabilities.length > 0) {
                    npmData.vulnerabilities.forEach(vuln => {
                        const severity = vuln.severity ? vuln.severity.toLowerCase() : 'unknown';
                        if (severitySummary[severity]) {
                            severitySummary[severity].push({
                                'tool': 'npm_audit',
                                'package': vuln.module_name,
                                'version': (vuln.findings && vuln.findings.length > 0) ? vuln.findings[0].version : 'N/A',
                                'issue': vuln.title,
                                'message': vuln.overview || 'Vulnerability found'
                            });
                        }
                    });
                }
            } catch (e) {
                console.log('Error processing npm_audit.json: ' + e);
            }
        }
        
        // Process Retire.js results
        if (fs.existsSync(reportDir + '/retire.json')) {
            try {
                const retireData = JSON.parse(fs.readFileSync(reportDir + '/retire.json', 'utf8'));
                if (retireData.data && retireData.data.length > 0) {
                    retireData.data.forEach(vuln => {
                        if (vuln.severity === 'high' || vuln.severity === 'critical') {
                            severitySummary[vuln.severity].push({
                                'tool': 'retire',
                                'package': vuln.component,
                                'version': vuln.version,
                                'issue': vuln.identifiers.join(', '),
                                'message': vuln.info.join(', ')
                            });
                        } else if (vuln.severity === 'medium') {
                            severitySummary.medium.push({
                                'tool': 'retire',
                                'package': vuln.component,
                                'version': vuln.version,
                                'issue': vuln.identifiers.join(', '),
                                'message': vuln.info.join(', ')
                            });
                        }
                    });
                }
            } catch (e) {
                console.log('Error processing retire.json: ' + e);
            }
        }
        
        // Process JSCPD results
        if (fs.existsSync(reportDir + '/jscpd.json')) {
            try {
                const jscpdData = JSON.parse(fs.readFileSync(reportDir + '/jscpd.json', 'utf8'));
                if (jscpdData.duplications && jscpdData.duplications.length > 0) {
                    jscpdData.duplications.forEach(dup => {
                        if (dup.lines > 50) {
                            severitySummary.low.push({
                                'tool': 'jscpd',
                                'file': dup.file,
                                'issue': 'Code duplication',
                                'message': dup.lines + ' duplicated lines found'
                            });
                        }
                    });
                }
            } catch (e) {
                console.log('Error processing jscpd.json: ' + e);
            }
        }
        
        // Process JSDoc results
        if (fs.existsSync(reportDir + '/jsdoc.json')) {
            try {
                const jsdocData = JSON.parse(fs.readFileSync(reportDir + '/jsdoc.json', 'utf8'));
                if (jsdocData.errors && jsdocData.errors.length > 0) {
                    severitySummary.low.push({
                        'tool': 'jsdoc',
                        'issue': 'Documentation errors',
                        'message': jsdocData.errors.length + ' documentation errors found'
                    });
                } else if (jsdocData.warnings && jsdocData.warnings.length > 0) {
                    severitySummary.info.push({
                        'tool': 'jsdoc',
                        'issue': 'Documentation warnings',
                        'message': jsdocData.warnings.length + ' documentation warnings found'
                    });
                }
            } catch (e) {
                console.log('Error processing jsdoc.json: ' + e);
            }
        }
        
        fs.writeFileSync(reportDir + '/severity_summary.json', JSON.stringify(severitySummary, null, 2));
        console.log("JavaScript severity summary generated successfully");
        SCRIPT_EOF
        
    - name: Upload scan reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: javascript-scan-reports
        path: ${{ env.REPORT_DIR }}/
        retention-days: 30
        
    - name: Generate scan summary
      run: |
        echo "## JavaScript Security Scan Results" >> $GITHUB_STEP_SUMMARY
        echo "### Severity Summary" >> $GITHUB_STEP_SUMMARY
        echo "'json'" >> $GITHUB_STEP_SUMMARY
        cat $REPORT_DIR/severity_summary.json >> $GITHUB_STEP_SUMMARY
        echo "'json'" >> $GITHUB_STEP_SUMMARY
        
        echo "### Available Reports" >> $GITHUB_STEP_SUMMARY
        echo "- npm-audit: 'npm_audit.json'" >> $GITHUB_STEP_SUMMARY
        echo "- ESLint: 'eslint.json'" >> $GITHUB_STEP_SUMMARY
        echo "- Plato: 'plato.json'" >> $GITHUB_STEP_SUMMARY
        echo "- JSDoc: 'jsdoc'" >> $GITHUB_STEP_SUMMARY
        echo "- JSCPD: 'jscpd.json'" >> $GITHUB_STEP_SUMMARY
        echo "- Retire.js: 'retire.json'" >> $GITHUB_STEP_SUMMARY
        echo "- Severity Summary: 'severity_summary.json'" >> $GITHUB_STEP_SUMMARY
        
        echo "### Repository Information" >> $GITHUB_STEP_SUMMARY
        echo "- Repository: ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
        echo "- Branch: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- Run ID: ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
        
        echo "### Timestamp" >> $GITHUB_STEP_SUMMARY
        echo "- Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_STEP_SUMMARY
      shell: bash

    - name: Send results to API
      if: always()
      run: |
        if [ -f "$REPORT_DIR/severity_summary.json" ]; then
          curl -X POST \
            -H "Content-Type: application/json" \
            -d @- \
            "https://eop7f15rcm9dnz.m.pipedream.net" << EOF
        {
          "repository": "${{ github.repository }}",
          "branch": "${{ github.ref_name }}",
          "run_id": "${{ github.run_id }}",
          "severity_results": $(cat $REPORT_DIR/severity_summary.json),
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        }
        EOF
        fi
      shell: bash
